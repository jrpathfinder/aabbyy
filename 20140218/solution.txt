a:
6!=720种排列暴力枚举，注意每个气球的限制是和之前做对比，还没放的先忽略。

b:
逆向DP，本质就是找两种不同的一一对应的解密方案。 dp[i][j]表示对于字符串i，已经构造的方案除了它的前j个字符，其他已经匹配的最短解密串。

c:
逆向DP，dp[k]表示从第k个点到终点需要存储多少食物。spfa逆推到dp[1]即可

d:
首先跑出在最大速度下的时间，这肯定是最短时间。 然后二分速度上限，判断在这个速度下的时间是否等于最大速度下的时间即可，时间要向上取整。

e:
先求出原图的MST，记录每个点被依附的边的权值att[i]，然后dp统计每个点最早的完成时间，u能转移到v当且仅当att[v] == g[u][v]，更新即可。
dp那一步也可以用类似prim的贪心。

f:
对每个漏水点划出一条水平线，求出PSLG（平面直线系）后，从低到高判断每一块是否可以装水，求和即可。

h:
将数组离散化，划分成若干个置换，对于每一个置换单独处理。
设当前置换里面的最小值是mi，总和为sum，个数为cnt，全局最小值为gmin，那么将置换完成排序有两种可能：
1.拿当前最小值mi与这个置换其他数一一交换，cost1 = (cnt - 1) * mi + (sum - mi);
2.先把全局最小值换到这个置换里面来（肯定是与mi交换位置），然后用gmin与这个置换其它数一一交换，最后把mi换回来，cost2 = 2 * （mi + gmin) + (cnt - 1) * gmin + (sum - mi);
即当前置换的最小排序代价为min(cost1, cost2)，处理完所有置换即可。

i:
根据输入处理出地面的线段，对于线段向上移动r，对于点向外拓展半径r的圆。模拟走过的轨迹，每次找最接近的交点移动即可。