
b:
10^18内，2，3，5，7这些因子的组合只有6W+种，DP一次表示用x个问号(2,3,5,7)的某种组合的方案数。注意的是有某一位位0，乘积为0

d:
考虑一条边(u, v)，要删除它至少删除u的出边或者v的入边，显然是一个最小割模型。

e:
容斥，注意不同容斥方法常数的不同。预处理出sigma(xi) <= S的不同方案数，然后减去全部数为0，或者K - 1个数为0的即可，这些都可以直接计数

g:
顺序枚举第一维，用set[len]维护每个长度下的2元组(val,pos)，val是代表val这个数，在第二维出现的位置为pos，显然如果val1 <= val2 && pos1 <= pos2，则val2,pos2是无用的，维护set里面二元组单调性即可。 求(i,j)这两位置的最大值，可以二分长度，并用set数组辅组判断是否成立。因为如果设(i,j)的最大值为max，那么小于等于max - 1的满足条件的二元组必然在其对应的set中存在。 (复杂度估计最坏是NMLOGK ~ NM(LOGK)^2，K约为sqrt(N)左右）。

h:
最优方案肯定是n -> i, i + 1 -> 1，枚举i求最优值即可。

k:
利用并查集和平衡树维护一段一段的区间，区间两端都必须是空位，如果每次插入后有两个区间相邻的情况则合并它们。
