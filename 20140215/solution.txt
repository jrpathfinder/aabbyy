a:
dp。
设状态dp[i][j][k]为白棋在i，黑棋在j，当前赌注为k先手的最大收益，
因为是dag，所以转移不会有环，转移方程：
dp[i][j][k] = max(max(-dp[ii][j][k + d[ii]]), max(-dp[i][jj][k - d[jj]]))
dp过程中一起记录方案数即可

b:
对于1，3，4，枚举第一行之后，其他行肯定确认了。
对于2，**.  变成 .** 后和3，4一样。
       * *       * *
       *..       ..*
题目数据比较大，利用数组计算出来上一行状态为mask的时候，这一行的翻转方案，同时记录代价和下一行收到的影响。 以后直接枚举第一行的方案，然后异或一下判断最后一行是否为0即可。

c:
离线处理，从高到低逐个方格添加
难点：
1.用pfs重新计算每个方格实际淹没时间
2.证明：每次统计的时候，块的数量种类较少，可用map记录统计

d:
因为硬币是近乎无穷的，所以直接判断是否存在s = x + y + z, x * a > s,y * b > s, z * c > s
即 x > s / a,y > s / b,z > s / c，即s * (1 / a + 1 / b + 1 / c) < x + y + z = s，即 1 / a + 1 / b + 1 / c < 1。注意精度g 

e:
从0到s枚举并模拟下注总金额，每一次都应该把这一元钱押到当前三种情况中收益最小的一个。

g:
floyd求出点与点之间的转移，需要注意的是可以ai > bi或ai > ci啥的，即这一天虽然依然停留在同一个点，但是这个点去了其他点然后再回到这个点，天数重新从1开始算的数据，
用dp[i][j][k]表示第i天在j点，已经停留了k天的最大值。dp[i][j][k]->dp[i + 1][jj][1]或者dp[i + 1][j][min(k + 1,3)]

h:
按照题意规则模拟既可